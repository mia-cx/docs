/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  LinkUpdater: () => LinkUpdater,
  default: () => TitleAsLinkTextPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
function basename(path) {
  const base = new String(path).substring(path.lastIndexOf("/") + 1);
  return base;
}
var DEFAULT_SETTINGS = {
  debounceDelay: 1e3,
  similarityThreshold: 0.65,
  useFrontmatterTitle: true,
  useFirstHeading: true,
  autoUpdate: true
};
var LinkUpdater = class {
  constructor(vault, metadataCache, settings) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
  }
  async updateAllLinks() {
    const markdownFiles = this.vault.getMarkdownFiles();
    let updatedBacklinksCount = 0;
    for (const file of markdownFiles) {
      const oldPath = file.path;
      const backLinks = await this.updateBackLinks(file, oldPath, false);
      if (backLinks) {
        updatedBacklinksCount = backLinks + updatedBacklinksCount;
      }
    }
    return updatedBacklinksCount;
  }
  async updateLinksInNote(file) {
    const fileContent = await this.vault.read(file);
    const fileCache = this.metadataCache.getFileCache(file);
    if (!fileCache) {
      return 0;
    }
    let updatedCount = 0;
    const markdownLinkRegex = /\[([^\]\n]+)\]\(([^)\n]+)\)/g;
    let newFileContent = fileContent.replace(
      markdownLinkRegex,
      (match, linkText, linkUrl) => {
        if (match.startsWith("[ ]") || match.startsWith("[x]")) {
          return match;
        }
        const linkUrlDecoded = decodeURIComponent(linkUrl);
        const baseLinkUrl = linkUrlDecoded.split("#")[0];
        if (baseLinkUrl == "") {
          return match;
        }
        const linkedFile = this.metadataCache.getFirstLinkpathDest(baseLinkUrl, file.path);
        if (linkedFile && linkedFile.name.endsWith(".md")) {
          const linkedCache = this.metadataCache.getFileCache(linkedFile);
          if (linkedCache) {
            const title = this.getPageTitle(linkedCache, linkedFile.path);
            if (linkText === title) {
              return match;
            }
            if (linkText.toLowerCase() === title.toLowerCase()) {
              updatedCount++;
              return `[${title}](${linkUrl})`;
            }
            const aliases = this.getAliases(linkedCache);
            const similarAlias = this.findMostSimilarAlias(linkText, aliases);
            if (similarAlias && similarAlias !== linkText) {
              updatedCount++;
              return `[${similarAlias}](${linkUrl})`;
            }
            if (!similarAlias) {
              const title2 = this.getPageTitle(linkedCache, linkedFile.path);
              if (linkText !== title2) {
                updatedCount++;
                return `[${title2}](${linkUrl})`;
              }
            }
          }
        }
        return `[${linkText}](${linkUrl})`;
      }
    );
    const wikilinkRegex = /\[\[([^\][\n]+?)(?:#([^\][\n]+?))?(?:\|([^\][\n]+?))?]]/g;
    newFileContent = newFileContent.replace(
      wikilinkRegex,
      (match, linkPath, subheading, linkText) => {
        var _a;
        if (subheading) {
          return match;
        }
        const linkedFile = this.metadataCache.getFirstLinkpathDest(linkPath, file.path);
        if (linkedFile) {
          const linkedCache = this.metadataCache.getFileCache(linkedFile);
          if (linkedCache) {
            const title = this.getPageTitle(linkedCache, linkedFile.path);
            if (linkText) {
              if (linkText === title) {
                return match;
              }
              const aliases = this.getAliases(linkedCache);
              const similarAlias = this.findMostSimilarAlias(linkText, aliases);
              if (similarAlias && similarAlias !== linkText) {
                updatedCount++;
                return `[[${linkPath}|${similarAlias}]]`;
              }
              if (!similarAlias && linkText !== title) {
                updatedCount++;
                return linkPath !== title ? `[[${linkPath}|${title}]]` : `[[${linkPath}]]`;
              }
            } else {
              const baseLinkName = ((_a = linkPath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "";
              if (title && title !== baseLinkName) {
                updatedCount++;
                return linkPath !== title ? `[[${linkPath}|${title}]]` : `[[${linkPath}]]`;
              }
            }
          }
        }
        return match;
      }
    );
    if (fileContent !== newFileContent) {
      await this.vault.modify(file, newFileContent);
    }
    return updatedCount;
  }
  async updateBackLinks(file, oldPath, notify) {
    if (!oldPath || !file.path.toLocaleLowerCase().endsWith(".md") || !(file instanceof import_obsidian.TFile)) {
      return;
    }
    const notes = this.getCachedNotesThatHaveLinkToFile(oldPath);
    let updatedBacklinksCount = 0;
    for (const note of notes) {
      const count = await this.updateLinksInNote(note);
      updatedBacklinksCount += count;
    }
    const selfCount = await this.updateLinksInNote(file);
    updatedBacklinksCount += selfCount;
    if (notify && updatedBacklinksCount > 0) {
      new import_obsidian.Notice(
        `Updated the link text of ${updatedBacklinksCount} Markdown link(s).`
      );
    }
    return updatedBacklinksCount;
  }
  getCachedNotesThatHaveLinkToFile(filePath) {
    const notesWithBacklinks = [];
    const allNotes = this.vault.getMarkdownFiles();
    if (allNotes) {
      for (const note of allNotes) {
        const notePath = note.path;
        if (note.path == filePath) {
          continue;
        }
        const noteCache = this.metadataCache.getCache(notePath);
        const embedsAndLinks = [
          ...(noteCache == null ? void 0 : noteCache.embeds) || [],
          ...(noteCache == null ? void 0 : noteCache.links) || []
        ];
        if (embedsAndLinks) {
          for (const link_data of embedsAndLinks) {
            const firstLinkPath = this.metadataCache.getFirstLinkpathDest(
              link_data.link,
              note.path
            );
            if (firstLinkPath && firstLinkPath.path == filePath) {
              notesWithBacklinks.push(note);
            }
          }
        }
      }
    }
    return notesWithBacklinks;
  }
  getPageTitle(cache, filePath) {
    const frontMatterTitle = this.settings.useFrontmatterTitle && cache.frontmatter && cache.frontmatter.title;
    const firstHeading = this.settings.useFirstHeading && cache.headings && cache.headings.length > 0 && cache.headings[0].heading;
    const title = frontMatterTitle || firstHeading || basename(filePath).replace(".md", "");
    return this.stripLinkElements(title);
  }
  getAliases(cache) {
    if (!cache.frontmatter || !cache.frontmatter.aliases) {
      return [];
    }
    const aliases = cache.frontmatter.aliases;
    if (Array.isArray(aliases)) {
      return aliases;
    } else if (typeof aliases === "string") {
      return [aliases];
    }
    return [];
  }
  findMostSimilarAlias(text, aliases) {
    for (const alias of aliases) {
      if (alias.toLowerCase().includes(text.toLowerCase()) || text.toLowerCase().includes(alias.toLowerCase())) {
        return alias;
      }
    }
    let mostSimilarAlias = null;
    let highestSimilarity = 0;
    for (const alias of aliases) {
      const similarity = this.calculateSimilarity(text, alias);
      if (similarity > highestSimilarity && similarity >= this.settings.similarityThreshold) {
        highestSimilarity = similarity;
        mostSimilarAlias = alias;
      }
    }
    return mostSimilarAlias;
  }
  calculateSimilarity(str1, str2) {
    const matrix = [];
    for (let i = 0; i <= str1.length; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= str2.length; j++) {
      matrix[0][j] = j;
    }
    for (let i = 1; i <= str1.length; i++) {
      for (let j = 1; j <= str2.length; j++) {
        if (str1[i - 1] === str2[j - 1]) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            // substitution
            matrix[i][j - 1] + 1,
            // insertion
            matrix[i - 1][j] + 1
            // deletion
          );
        }
      }
    }
    const distance = matrix[str1.length][str2.length];
    const maxLength = Math.max(str1.length, str2.length);
    return 1 - distance / maxLength;
  }
  stripLinkElements(text) {
    let result = text.replace(/\[([^\]]+)\]\([^)]+\)/g, "$1");
    result = result.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (match, link, displayText) => {
      return displayText || link;
    });
    return result;
  }
};
var TitleAsLinkTextPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.linkUpdater = new LinkUpdater(
      this.app.vault,
      this.app.metadataCache,
      this.settings
    );
    this.debouncedUpdateBackLinks = (0, import_obsidian.debounce)(
      this.linkUpdater.updateBackLinks.bind(this.linkUpdater),
      this.settings.debounceDelay,
      true
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        if (this.settings.autoUpdate && file instanceof import_obsidian.TFile) {
          this.debouncedUpdateBackLinks(file, oldPath, true);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file) => {
        if (this.settings.autoUpdate) {
          this.debouncedUpdateBackLinks(file, file.path, true);
        }
      })
    );
    this.addCommand({
      id: "update-all-links",
      name: "Update all links",
      callback: async () => {
        const count = await this.linkUpdater.updateAllLinks();
        new import_obsidian.Notice(`Updated the link text of ${count} Markdown link(s).`);
      }
    });
    this.addCommand({
      id: "update-current-file-links",
      name: "Update links for current file",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          const backLinks = await this.linkUpdater.updateBackLinks(activeFile, activeFile.path, false);
          if (backLinks) {
            new import_obsidian.Notice(`Updated the link text of ${backLinks} Markdown link(s) in the current file.`);
          }
        } else {
          new import_obsidian.Notice("No active markdown file found.");
        }
      }
    });
    this.addSettingTab(new TitleAsLinkTextSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.debouncedUpdateBackLinks = (0, import_obsidian.debounce)(
      this.linkUpdater.updateBackLinks.bind(this.linkUpdater),
      this.settings.debounceDelay,
      true
    );
  }
};
var TitleAsLinkTextSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Auto-update").setDesc("Automatically update links when notes are saved or renamed").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoUpdate).onChange(async (value) => {
      this.plugin.settings.autoUpdate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Title source").setHeading();
    new import_obsidian.Setting(containerEl).setName("Title from frontmatter").setDesc("Use the title field from frontmatter as the link text (if available)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useFrontmatterTitle).onChange(async (value) => {
      this.plugin.settings.useFrontmatterTitle = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Title from first heading").setDesc("Use the first heading in the note as the link text").addToggle((toggle) => toggle.setValue(this.plugin.settings.useFirstHeading).onChange(async (value) => {
      this.plugin.settings.useFirstHeading = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Advanced").setHeading();
    new import_obsidian.Setting(containerEl).setName("Debounce delay").setDesc("How long to wait (in milliseconds) before updating links after a change").addText((text) => text.setPlaceholder("1000").setValue(String(this.plugin.settings.debounceDelay)).onChange(async (value) => {
      const delay = Number(value);
      if (!isNaN(delay) && delay > 0) {
        this.plugin.settings.debounceDelay = delay;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Similarity threshold").setDesc("Minimum similarity score (0.0 to 1.0) required for alias matching. Higher values require closer matches.").addText((text) => text.setPlaceholder("0.65").setValue(String(this.plugin.settings.similarityThreshold)).onChange(async (value) => {
      const threshold = Number(value);
      if (!isNaN(threshold) && threshold >= 0 && threshold <= 1) {
        this.plugin.settings.similarityThreshold = threshold;
        await this.plugin.saveSettings();
      }
    }));
  }
};

/* nosourcemap */